# -*- coding: utf-8 -*-

# Run this Python/Numpy test script and compare its output to the output
# generated by `test_pcg64dxsm.c`. It will (should) produce exactly the same
# sequences of random integers, also after "jumping". 
#
# This demonstrates that # the PCG64DXSM RNG in `randommw.c` is working 
# correctly and in conformity to # the PCG64DXSM RNG in Numpy.
#
# The PCG64DXSM initialization code in randommw.c has been modified
# to reproduce exactly the state of the PCG64DXSM RNG obtained by 
# numpy.random.PGC64DXSM(seed = 0) and PGC64DXSM(seed = 12345).
# This is not automatic, since the initialization of PCG64DXSM is not the 
# same in randommw.c and in Numpy. # It is not feasible to use exactly the same
# initialization of the PCG64DXSM in `randommw.c` as in Numpy. The latter
# depends on the specific Numpy infrastructure. In `randommw.c`, SplitMix64 
# is used for initialization.


from numpy.random import PCG64DXSM


for s, Njmp in zip([0, 12345],
                   [7, 64738]):
    print()
    print(60*"*")
    print(f"*** Seed : {s} ")
    print(60*"*")
    
    #  initialize PCG64DXSM with a given seed
    rng = PCG64DXSM(seed = s)
        
    print("state:", hex(rng.state['state']['state']))
    print("inc:  ", hex(rng.state['state']['inc']))
    print()
    
    for i in range(10):
        print(rng.random_raw())
    
    print()
    print("state:", hex(rng.state['state']['state']))
    print("inc:  ", hex(rng.state['state']['inc']))
    
    print()
    print(f'>>> JUMP! ({Njmp} steps)')    
    rng2 = rng.jumped(Njmp)
    print()
    
    # don't forget that the jumped rng is 'rng2' !!
    print("state:", hex(rng2.state['state']['state']))
    print("inc:  ", hex(rng2.state['state']['inc']))
    print()
    
    for i in range(10):
        print(rng2.random_raw())
    print(60*"*")
    print()
